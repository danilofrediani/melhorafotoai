import { supabase } from './supabase';
import type { User as DbUser, Package, Transaction, UploadedImage, ProcessedImage, PlatformSettings, Client, Project, Subscription } from './types';
import type { User as SupaUser } from '@supabase/supabase-js';

// As interfaces e outros services permanecem como na última versão funcional que te enviei
export interface AnalyticsData { total_revenue: number; images_processed: number; new_users: number; sales_by_package_type: Record<string, { total: number, count: number }>; processing_by_category: Record<string, number>; }
export const userService = { async getUserById(id: string): Promise<DbUser | null> { const { data, error } = await supabase.rpc('get_user_profile'); if (error) { console.error("Erro ao buscar perfil do usuário via RPC:", error); throw error; } return data?.[0] || null; }, async ensureUserRecord(supaUser: SupaUser): Promise<DbUser | null> { try { const existing = await this.getUserById(supaUser.id); if (existing) return existing; const nameFromMeta = (supaUser.user_metadata?.name as string | undefined) || (supaUser.user_metadata?.full_name as string | undefined) || (supaUser.email?.split('@')[0] ?? 'Usuário'); const typeFromMeta = (supaUser.user_metadata?.user_type as DbUser['user_type'] | undefined) || 'basic'; const insertPayload = { id: supaUser.id, email: supaUser.email, name: nameFromMeta, user_type: typeFromMeta, remaining_images: 2 }; const { data, error } = await supabase.from('users').insert(insertPayload).select().single(); if (error) { throw error; } return data as DbUser; } catch (err) { console.error("Erro geral em ensureUserRecord:", err); return null; } }, async getCurrentUser(): Promise<DbUser | null> { const { data: { user } } = await supabase.auth.getUser(); if (!user) return null; return await this.getUserById(user.id); }, async getUserRole(id: string): Promise<DbUser['user_type'] | null> { const { data, error } = await supabase.from('users').select('user_type').eq('id', id).single(); if (error) return null; return data?.user_type ?? null; }, async updateUser(id: string, updates: Partial<DbUser>): Promise<DbUser> { const { data, error } = await supabase.from('users').update(updates).eq('id', id).select().single(); if (error) throw error; return data as DbUser; }, async updateLastLogin(id: string): Promise<void> { await supabase.from('users').update({ last_login: new Date().toISOString() }).eq('id', id); }, async decrementUserCredits(id: string, amount: number = 1): Promise<void> { const { error } = await supabase.rpc('decrement_user_credits', { user_id: id, credit_amount: amount }); if (error) throw error; }, };
export const packageService = { async getActivePackages(): Promise<Package[]> { const { data, error } = await supabase.from('packages').select('*').eq('is_active', true).order('sort_order'); if (error) throw error; return (data || []) as Package[]; }, async getPackageById(id: string): Promise<Package | null> { const { data, error } = await supabase.from('packages').select('*').eq('id', id).single(); if (error) return null; return data as Package; }, async createPackage(newPackageData: Omit<Package, 'id' | 'created_at'>): Promise<Package> { const { data, error } = await supabase.from('packages').insert(newPackageData).select().single(); if (error) { console.error("Erro ao criar pacote:", error); throw error; } return data as Package; }, async updatePackage(id: string, updates: Partial<Package>): Promise<Package> { const { data, error } = await supabase.from('packages').update(updates).eq('id', id).select().single(); if (error) { console.error("Erro ao atualizar pacote:", error); throw error; } return data as Package; }, async deletePackage(id: string): Promise<void> { const { error } = await supabase.from('packages').delete().eq('id', id); if (error) { console.error("Erro ao deletar pacote:", error); throw error; } } };
export const transactionService = { async createTransaction(transaction: Omit<Transaction, 'id' | 'created_at'>): Promise<Transaction> { const { data, error } = await supabase.from('transactions').insert(transaction).select().single(); if (error) throw error; return data as Transaction; }, async getTransactionsForUser(userId: string): Promise<(Transaction & { packages: { name: string } | null })[]> { const { data, error } = await supabase.from('transactions').select('*, packages(name)').eq('user_id', userId).order('created_at', { ascending: false }); if (error) throw error; return (data || []) as (Transaction & { packages: { name: string } | null })[]; }, async updateTransactionStatus(id: string, status: Transaction['status']): Promise<void> { const updates: Record<string, unknown> = { status }; if (status === 'completed') { (updates as any).completed_at = new Date().toISOString(); } const { error } = await supabase.from('transactions').update(updates).eq('id', id); if (error) throw error; } };
export const subscriptionService = { async getActiveSubscription(userId: string): Promise<(Subscription & { packages: { name: string } | null }) | null> { if (!userId) return null; const { data, error } = await supabase.from('subscriptions').select('*, packages(name)').eq('user_id', userId).eq('status', 'active').order('created_at', { ascending: false }).limit(1).single(); if (error && error.code !== 'PGRST116') { console.error('Erro ao buscar assinatura ativa:', error); throw error; } return data as (Subscription & { packages: { name: string } | null }) | null; } };
export const imageService = { async getProcessedImagesForUser(userId: string): Promise<ProcessedImage[]> { if (!userId) return []; const { data, error } = await supabase.from('processed_images').select('*').eq('user_id', userId).order('created_at', { ascending: false }); if (error) { console.error("Erro ao buscar imagens processadas do usuário:", error); throw error; } return data || []; }, async getImagesForProject(projectId: string, userId: string): Promise<ProcessedImage[]> { if (!projectId || !userId) return []; const { data, error } = await supabase.from('processed_images').select(`*, uploaded_image:uploaded_images(file_path, original_filename)`).eq('project_id', projectId).eq('user_id', userId).order('created_at', { ascending: false }); if (error) { console.error("Erro ao buscar imagens do projeto:", error); throw error; } return data || []; }, async getUnassignedImages(userId: string): Promise<ProcessedImage[]> { if (!userId) return []; const { data, error } = await supabase.from('processed_images').select(`*, uploaded_image:uploaded_images(file_path, original_filename)`).eq('user_id', userId).is('project_id', null).order('created_at', { ascending: false }); if (error) { console.error("Erro ao buscar imagens avulsas:", error); throw error; } return data || []; }, async assignImagesToProject(imageIds: string[], projectId: string): Promise<void> { const { error } = await supabase.from('processed_images').update({ project_id: projectId }).in('id', imageIds); if (error) { console.error("Erro ao mover imagens para o projeto:", error); throw error; } } };
export const adminService = { async getAllUsers(): Promise<DbUser[]> { const { data, error } = await supabase.rpc('get_all_users_with_stats'); if (error) { console.error("Erro ao chamar RPC get_all_users_with_stats:", error); throw error; } return (data || []) as DbUser[]; }, async getAnalyticsData(year: number, month: number): Promise<AnalyticsData> { const { data, error } = await supabase.rpc('get_analytics_data', { filter_year: year, filter_month: month }); if (error) { console.error("Erro ao buscar dados de analytics:", error); throw error; } return data; }, async getPlatformSettings(): Promise<PlatformSettings> { const { data, error } = await supabase.from('platform_settings').select('*').eq('id', 1).single(); if (error) { console.error('Erro ao buscar configurações da plataforma:', error); throw error; } return data; }, async updatePlatformSettings(updates: Partial<PlatformSettings>): Promise<PlatformSettings> { const { data, error } = await supabase.from('platform_settings').update(updates).eq('id', 1).select().single(); if (error) { console.error('Erro ao atualizar configurações da plataforma:', error); throw error; } return data; }, async getAllTransactions(): Promise<Transaction[]> { const { data, error } = await supabase.from('transactions').select('*, users(name, email), packages(name)').order('created_at', { ascending: false }); if (error) throw error; return (data || []) as Transaction[]; }, async getAppStats(): Promise<{ totalUsers: number; totalRevenue: number; totalImagesProcessed: number; activeSubscriptions: number; }> { const { count: totalUsers, error: usersError } = await supabase.from('users').select('*', { count: 'exact', head: true }); if (usersError) throw usersError; const { data: transactions, error: transactionsError } = await supabase.from('transactions').select('amount').eq('status', 'completed'); if (transactionsError) throw transactionsError; const { count: imagesCount, error: imagesError } = await supabase.from('processed_images').select('*', { count: 'exact', head: true }); if (imagesError) throw imagesError; const { data: activeSubsData, error: subsError } = await supabase.from('users').select('id').neq('subscription_status', 'free'); if (subsError) throw subsError; return { totalUsers: totalUsers || 0, totalRevenue: transactions?.reduce((sum, t) => sum + Number(t.amount), 0) || 0, imagesProcessed: imagesCount || 0, activeSubscriptions: activeSubsData?.length || 0, }; } };
export const clientService = { async getClientsForUser(userId: string): Promise<Client[]> { if (!userId) return []; const { data, error } = await supabase.from('clients').select('*').eq('user_id', userId).order('created_at', { ascending: false }); if (error) { console.error('Erro ao buscar clientes:', error); throw error; } return data || []; }, async createClient(clientData: { user_id: string; name: string; email?: string; notes?: string; phone?: string }): Promise<Client> { const { data, error } = await supabase.from('clients').insert(clientData).select().single(); if (error) { console.error('Erro ao criar cliente:', error); throw error; } return data; }, async updateClient(clientId: string, updates: { name: string; email?: string; notes?: string; phone?: string }): Promise<Client> { const { data, error } = await supabase.from('clients').update(updates).eq('id', clientId).select().single(); if (error) { console.error('Erro ao atualizar cliente:', error); throw error; } return data; } };
export const projectService = { async getProjectsForUser(userId: string): Promise<Project[]> { if (!userId) return []; const { data, error } = await supabase.from('projects').select(`*, client:clients(name), images:processed_images(count)`).eq('user_id', userId).order('created_at', { ascending: false }); if (error) { console.error('Erro ao buscar projetos:', error); throw error; } return data?.map(p => ({ ...p, client_name: p.client?.name })) || []; }, async getProjectById(projectId: string, userId: string): Promise<Project | null> { const { data, error } = await supabase.from('projects').select(`*, client:clients(name)`).eq('id', projectId).eq('user_id', userId).single(); if (error) { console.error('Erro ao buscar projeto por ID:', error); return null; } if (!data) return null; return { ...data, client_name: data.client?.name } as Project; }, async createProject(projectData: { user_id: string; name: string; client_id?: string }): Promise<Project> { const { data, error } = await supabase.from('projects').insert({ ...projectData, status: 'active' }).select().single(); if (error) { console.error('Erro ao criar projeto:', error); throw error; } return data; }, async updateProject(projectId: string, updates: { name: string; client_id?: string; status: string }): Promise<Project> { const { data, error } = await supabase.from('projects').update(updates).eq('id', projectId).select().single(); if (error) { console.error('Erro ao atualizar projeto:', error); throw error; } return data; } };
export const reportService = { async getReportData(userId: string, startDate: string, endDate: string): Promise<any> { if (!userId) return null; const { data, error } = await supabase.rpc('get_professional_report', { user_id_input: userId, start_date: startDate, end_date: endDate }); if (error) { console.error("Erro ao buscar dados do relatório:", error); throw error; } return data; } };
